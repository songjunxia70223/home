{"./":{"url":"./","title":"前言","keywords":"","body":"Introduction emmm...因为之前的项目太乱了...所以想着重构一下,重新整理一下,顺便发布到GitHub提供的静态网页上,这样能有更好的浏览体验吧,然后把每个部分的示例代码都分开,不要在一份代码上迭代,应该能看得更明白点...点击上面的阅读按钮就可以访问到一个还算漂亮的文档了~ 计划 简单写些本文档计划写的东西吧. 首先是Java自身的一些语法特性,我们平常使用的Java环境是Java SE,也就是Standard Edition标准版. 然后是Java EE,Java EE就是的Java企业版DLC,在Java SE上又增加了一些企业版开发所需要的类库,比如众所周知的Servlet,JSP,JDBC,JPA等等 接着是Spring全家桶. 会穿插在其中写一些流行的工具的使用方法,比如Redis/非关系型数据库,RabbitMQ/消息队列. 如果有时间还会写一些前端的部分. 还有计算机最重要的东西!数据结构和算法...每天会更新至少一道算法题吧,目前我是希望能做到的...刚开始希望能更新多点~ 我的看法 编程语言 关于我对编程的看法... 我觉得最重要的是,不要让编程语言成为自己的限制. 至少我会用的编程语言...TypeScript,JavaScript,Dart,Java,Bash,Python...当然我大部分只是知道语法,简单用来做过一些自己觉得好玩的小东西.我记得我Dart大概是一个多小时看完语法然后开始做Flutter的. 所以我觉得编程并不是学习编程语言,编程语言没什么好学的,要学的是它解决问题的方向,以及为了解决这个方向上的问题所提供的生态环境. 现今流行的编程语言,基本都是为了简单好用而开发出来的,不存在什么学习难度. 所有的当今编程语言的最基本构成是: 循环 条件 也就是流程控制,只要会控制程序运行的流程,就能配合生态做几乎所有的事了. 比如现在流行的是Python,那么Python目前流行的方向是什么?人工智能,科学计算,大数据,算法之类的. Python是众说周知地简单,你见过有人说Python难的吗?那为什么Python工资高?解决的问题应该和它的高薪所匹配,所以难的是它解决问题的方向,难在人工智能,科学计算上.而不是语言本身的难度带给它价值. 学习编程,更多的是学习编程语言对应的方向生态环境. 学习JavaScript,CSS,HTML,对应的是根据设计师提供的图来实现对应的网页效果. 学习Java,对应的是Web后端服务器的各种业务问题的解决与优化. 学习Python,对应人工智能,科学计算,也可以用于快速解决并不复杂的问题. 学习C语言,对应的是嵌入式开发 学习C#,对应的微软的生态. 编程语言是为了解决一个方向上的问题而诞生的,解决问题的方法是一系列算法组合成的,而为了让自己写出的算法有最大的性能表现,所以又有各种数据结构,每种数据结构所适应的算法是不同的. 毕竟编程的本质就是01010101嘛,再复杂的程序也不过是各种数据构成的...所以算法和数据结构是编程最重要的部分. 大部分的编程语言的语法,都是很简单的,不会浪费太多时间,有一定数据结构和算法的能力,学习编程不过水到渠成.所以我真的希望...不要因为觉得轻松去学测试...如果是为了轻松无聊而选择测试,那是没有一点价值的...抱着这种心态选择测试...也不可能被大公司录用的即使条件比后端和前端都要低一些. 希望,不要得过且过... 后端 由于我目前打算学习的是后端,至于为什么学,自然是因为在工资上普遍比前端高,而更高的那些比如算法岗位,大部分都是需要研究生的...我目前没打算读研,所以暂时只能退而求其次选择后端.现在我对后端整体还是有所了解的.所以大概写一下需要学习的东西,算是一个大纲了. 我觉得不要从语法开始学,没有什么意义...直接去学生态环境,从生态开始一点点了解它的基础语法,一步步拓展对该语言的了解,了解该语言的特性. 所以我会按照下面的流程编写该文档. Java环境配置 Spring的基本使用 Java基本语法 Java设计模式 Servlet基本使用 Spring MVC的基本使用 Java高级语法/此高级非彼高级~ Spring Boot基本使用 Servlet拓展 Spring拓展 Spring MVC拓展 Spring Boot拓展 JVM虚拟机 Java多线程 Java网络编程 Spring Cloud/分布式 微服务 就这么些东西,中间会穿插着写一些别的东西,然后每天更新点算法/数据结构 我觉得暑假的两个月我是可以把这些都写完的~ 我个人的小小愿望...希望你能看完吧...... Copyright © song_jx 2019 all right reserved，powered by Gitbook修订时间: 2019-06-10 23:20:35 "},"LOG.html":{"url":"LOG.html","title":"更新日志","keywords":"","body":"更新日志 %accordion%2019/6/10%accordion% [!NOTE] 基础排序 选择排序 插入排序 希尔排序 Java基础 Java环境 Java基础语法 %/accordion% %accordion%2019/6/11%accordion% [!NOTE] 基础排序 冒泡排序 归并排序 %/accordion% %accordion%2019/6/12%accordion% [!NOTE] 基础排序 快速排序 %/accordion% %accordion%2019/6/12%accordion% [!NOTE] LeetCode排序 查找两个有序数列的中位数 %/accordion% Copyright © song_jx 2019 all right reserved，powered by Gitbook修订时间: 2019-06-13 23:57:40 "},"Chapter0/":{"url":"Chapter0/","title":"Algorithms","keywords":"","body":"Algorithms 该算法部分设定下分为以下几部分 基础部分 排序 数据结构 进阶部分 进阶部分基本上为从LeetCode上摘录的算法原题的题解. 加上一些我自己理解的解释. 示例代码项目所在目录为 Algorithms Copyright © song_jx 2019 all right reserved，powered by Gitbook修订时间: 2019-06-22 23:01:58 "},"Chapter0/basic/0.1.1.html":{"url":"Chapter0/basic/0.1.1.html","title":"数据结构与算法","keywords":"","body":"排序 首先根据面向接口编程的思想,定义一个接口Sort package basic.sort; public interface Sort { void sort(int[] a); default void exch(int[] a, int i, int j) { int temp = a[i]; a[i] = a[j]; a[j] = temp; } } 很简单,包括一个sort抽象和一个默认方法exch...可以想象到在排序过程中经常出现交换位置的情况,所以增加了该默认方法避免重复代码. 点击标题查看实例代码. 冒泡排序 package basic.sort; public class Bubble implements Sort { @Override public void sort(int[] a) { //i来判断进行了几轮排序,最大轮次=数组长度-1 for (int i = 0; i a[j + 1]) { exch(a, j, j + 1); } } } } } 冒泡算法是最基础的算法,应该注释就够了,原理的话: 网上找到的容易看懂的图. 只比较相邻的元素,如果相邻元素的顺序相反的话就交换,一直将该轮次的数字交换到正确的位置. 因为数字是依次向上冒头,或许看着像冒泡吧...所以叫冒泡排序... 选择排序 package basic.sort; public class Selection implements Sort { @Override public void sort(int[] a) { //用i索引当前排序到第几个位置 for (int i = 0; i 简单说明一下选择排序吧 利用一个临时变量min,将目前遇到的最小的数字的索引位置存起来,如果碰到比该数字小的,就交换这两个数字的位置. 然后创建一个Main方法用来测试我们写好的排序. import basic.sort.Sort; import basic.sort.Selection; import java.util.Arrays; public class Main { public static void main(String[] args) { Sort sort = new Shell(); int[] a = new int[] { 2, 5, 4, 1, 3 }; sort.sort(a); System.out.println(Arrays.toString(a)); } } 在终端执行命令 javac Main.java java Main 对了,如果java文件中有中文注释,需要声明用-encoding utf-8进行编译,不然会出现编码错误. 所以如果有中文注释,我们显式用该命令编译 javac -encoding UTF-8 Main.java 目前目录状况如下. 接下来就不一一赘述这些东西了...详情参考示例代码. 插入排序 import basic.sort.Sort; public class Insertion implements Sort { @Override public void sort(int[] a) { //i表示当前有几个数字是有序的 for (int i = 1; i 0; j--) { //如果j的前一个比j小,就将它插到前面. if (a[j - 1] > a[j]) { exch(a, j, j - 1); } } } } } 看着好像比选择排序还简单的样子233333 不过实际上效率要高出很多...简单说明: 对比从a[i]到a[0]之间的数字,如果a[i-1]>a[i],就交换顺序,每次只挪动一个位置.遍历一遍后依次将数字移动到正确的位置就可以了. 测试的时候将Main方法里的new Selection()修改为new Insertion()就可以了 希尔排序 希尔排序/Shell Sort是插入排序的改良版. 在观察插入排序的时候,每次都只交换一个位置,可能要交换很多次才能到正确的地方.那么我们就考虑尽可能地将它挪动到最远的地方. 在这里给出一个概念吧...2-有序,4-有序,8-有序的意思是,每隔x个的数字是有序的,至于x之间的数字则先不考虑...比如这个数组 2,1,4,3,6,3,8,1,10 这个就是一个2-有序数组,因为2,4,6,8,10是有序的. 所以我们就考虑利用插入排序,每次不止挪动一个位置,而是x个位置,先让它变成x-有序就可以了.所以有如下实现 package basic.sort; public class Shell implements Sort { @Override public void sort(int[] a) { int N = a.length; int h = 1; //设置一个数字,表示每次挪动h个位置,希尔排序的性能取决于该数字的算法. //简单起见我只是将该数字设置小于length的最大2^n while (h = 1) { //下面类似插入排序了,只是每次如果需要插入,则直接插入到前面h个位置的地方 for (int i = h; i = h; j -= h) { if (a[j] 参考如上.我们先构造了一个尽可能大的数字,比如这里我们利用循环构造了一个数字2^n 比如length长度为20,那么h就是16,然后第一遍循环先看第16个数字跟第一个数字的大小,视情况交换,然后j=j-h...然后比较a[17]和a[1]...... 第一遍结束后应该是个16-有序数组,然后让h=h/2,让这个数组变为8-有序,4-有序,2-有序,1-有序... 1-有序自然就是一个常规的有序列表了 还是很简单的... 归并排序 我们先写归并排序的原理吧: 归并排序是将两个有序数组归并为一个有序数组的算法,也就是说必须提供给它两个有序数组. 我们根据这个思路先将归并的算法写出来,然后再考虑两个数组不是有序的情况. package basic.sort; public class Merge implements Sort { public int[] merge(int[] a, int[] b) { //新建一个数组,用来存放归并后的结果 int[] result = new int[a.length + b.length]; //i表示当前归并到第一个数组的第i个位置 //j表示归并到第二个数组的第j个位置 //k表示归并到结果数组的第k个位置 int i = 0, j = 0, k = 0; while (i b[j]) { result[k++] = b[j++]; } else { result[k++] = a[i++]; result[k++] = b[j++]; } } //这两个循环是可能存在两个数组长度不相等的情况. while (i 这是提供两个有序数组时候的算法.不算难,那么考虑下如何利用该算法将一个无序数组归并为一个有序数组? 首先我们想想如何在一个数组中进行归并,我们可以人为的利用一个变量将一个数组分为两个,比如mid表示中间,将mid左右两边的数字分别利用上面的思路归并. 然后我们实现另一种归并算法 public int[] merge(int[] a) { int mid = a.length / 2; int[] result = new int[a.length]; //i表示数组左半边归并到第i个位置 //j表示数组右半边归并到第i个位置 //k表示结果数组归并到的位置 int i = 0, j = mid + 1, k = 0; for (; k mid,说明左半边归并结束了,但是右半边还存在没有数组归并到结果中 if (i > mid) result[k] = a[j++]; //同上一个判断. else if (j > hi) result[k] = a[i++]; //将较小的放到结果数组中. //其中相等的情况我们利用上面两个判断进行了归并,所以这里并不需要再进行多余的判断了 else if (a[j] 那么继续思考,怎么在两边都无序的情况下归并呢? 简单想想,我们可以利用递归.为什么利用递归呢? 如果数组中只有2个数字,那么左右半边两边是不是有序的呢? 如果数组中有4个数字,我们可以拆分为左右两个2个数字的数组对吧? 那么把左右两个数组排序好了后,这个4个数字的数组是不是就存在两个有序数组呢? 所以可以利用递归,从2个长度的数组开始归并,一直归并到整个数组就结束. 那么有如下的完整实现. public class Merge implements Sort { //我们声明一个临时变量,用来存放需要排序的数组,将结果放在原数组中 //可以避免我们利用return来返回result结果 private int[] aux; @Override public void sort(int[] a) { //实例化临时变量为排序数组的长度 aux = new int[a.length]; //利用另一个方法进行数组的递归拆分操作. //所以要先将排序数组完整的传给该方法. sort(a, 0, a.length - 1); } //用来递归拆分数组的排序方法. //lo表示数组的最低边界,hi表示数组的最高边界. private void sort(int[] a, int lo, int hi) { //最低边界大于最高边界,就返回. if (hi mid) a[k] = aux[j++]; else if (j > hi) a[k] = aux[i++]; else if (aux[j] 归并排序算法到这里就结束了~里面涉及的东西还是挺多的...我觉得这里开始排序算法才有一定难度了.递归这里如果不深入思考的话也是挺难想到如何实现的... 首先归并排序在数组长度较小时效率并不高,可以看到我们进行了很多的循环,但是在数组长度过长的时候可能就会有栈溢出报错的情况,所以递归实现并不算是一个最优解... 我们数据结构与算法中学习过如何将递归改造为栈,所以我们是可以通过一个栈的数据结构将递归进行改造,在随后有机会会进行改进. 至于优化归并排序本身性能的话,可以考虑在递归进行归并的时候,如果数组长度较小,也就是hi-lo比较小的时候,可以利用插入排序,插入排序在数组长度较小时是一个很好用的排序算法. 快速排序 快速排序的思想有些类似归并排序. 归并排序是通过递归将两个有序数组归并为一个有序数组. 快速排序是通过递归将数组分为两部分: 设定一个key值,可以是数组的第一个元素,然后将整个数组分为不大于key的部分和不小于key的部分. 然后将key所在位置为分界,再将左边分为两部分,右边分为两部分. 根据思路有如下实现 package basic.sort; public class Quick implements Sort { //利用另一个private方法来进行递归调用 @Override public void sort(int[] a) { //与归并排序类似,传数组的上下边界 sort(a, 0, a.length - 1); } private void sort(int[] a, int lo, int hi) { //hi自然是不能小于等于lo的 if (hi key)if(right==lo)break; //如果找到的值在错误的位置,就交换它们 if (left 我们想想第二个边界判断 if(right==lo) 首先当right==lo的时候a[right]=key,所以该循环就结束了,该if条件是多余的. 那第一个判断呢?因为可能存在最后一个值依然比key小的情况,所以如果不判断的话在下一轮循环++left的时候就会出现数组越界. 那么如果最后一个值本身就是最大值,这里的判断条件就可以去掉了吧~ 所以我们利用一个循环,先将最大值放到最末尾的位置,然后再进行排序,我们在sort方法里添加如下代码. @Override public void sort(int[] a) { int max = 0; for (int i = 1; i 先将最大值放到末尾,然后再进行循环.这个时候去掉两个那两个边界判断就没什么问题了~ 为什么这么做...因为在数组长度很长的时候进行多次判断还是会消耗一定时间的.通过一劳永逸的方法去掉判断语句能一定程度提高效率. 最终结果就不贴了...参考示例代码~ Copyright © song_jx 2019 all right reserved，powered by Gitbook修订时间: 2019-06-22 23:01:58 "},"Chapter0/basic/0.1.1.1.html":{"url":"Chapter0/basic/0.1.1.1.html","title":"数据结构","keywords":"","body":"数据结构 数据结构只是数据的存储方式而已,为了让数据集合能够适用于一些场景,提出来的一些适用于特定场景的存储数据的方式. 栈 实现 基础的栈和队列就用一个实现和一个算法一笔带过吧. 栈是一个先进后出的数据结构,也就是说越早放进去的数据在读取时候的顺序就越靠后. 设想下栈所需要的方法. push()将数据存储到末尾 pop()将最后存储的数据返回并从集合(栈)中删除 peek()将最后存储的数据返回,不删除. empty()返回栈是否为空 我们设计实现一下这几个方法,实现如下. package basic.structure; public class Stack { private Integer[] el; private Integer length; //利用构造函数初始化栈的长度. //利用java重载的特性,编写了两个构造函数,默认栈长度为10. //length设置为-1是为了方便索引,因为数组是从0开始索引的. public Stack(Integer length) { el = new Integer[length]; this.length = -1; } public Stack() { el = new Integer[10]; this.length = -1; } //当length=-1的时候证明栈还没有存放元素. public boolean empty() { return length == -1; } //判断栈是否存满 //索引length+1后存储数据 public void push(Integer element) { if (length -1) { Integer temp = el[length]; el[length--] = null; return temp; } return null; } //将栈顶元素返回 public Integer peek() { if (length > -1) { return el[length]; } return null; } } 这样一个最基本的栈就编写好了,写个main方法测试一下 public static void main(String[] args) { Stack stack = new Stack(); for (Integer i = 0; i 可以看到结果是倒叙输出的... 然而我们实现的这个栈泛用性太低了,只能存储integer类型的值,所以后续会完善该结构. 应用 实际上Java已经实现过栈这个数据结构了,所以我们其实是可以直接使用的.我们就用Java自带的栈来编写一个简单的判断括号有效性的算法吧~ 判断规则:给定一个只包含\"(){}[]\"的字符串,如果所有的左括号对应存在右括号闭合,则判断为true,否则为false. public boolean isValid(String s) { //new一个Stack实例,使用泛型确定它存储的为Character(字母) Stack res = new Stack<>(); //将字符串转为字母数组 char[] temp = s.toCharArray(); //字符串必须以左括号开始. if (temp.length > 1 && temp[0] != '(' && temp[0] != '[' && temp[0] != '{') return false; //遍历循环列表 for (char c : temp) { try { //如果是左括号,就push进栈 switch (c) { case '(': res.push(c); break; case '[': res.push(c); break; case '{': res.push(c); break; //如果为右括号,则判断栈顶是否对应存在左括号,存在则pop出栈,否则返回false case ')': if (res.peek() == '(') { res.pop(); break; } else return false; case ']': if (res.peek() == '[') { res.pop(); break; } else return false; case '}': if (res.peek() == '{') { res.pop(); break; } else return false; } } catch (Exception e) { return false; } } //如果最终栈为空,则证明所有的左括号都有对应的右括号,即为有效. return res.empty(); } 然后写一个main方法测试一下. public static void main(String[] args) { BracketIsValid bracket = new BracketIsValid(); System.out.println(bracket.isValid(\"({})\")); System.out.println(bracket.isValid(\"({}\")); } 应该输出true跟false. 该算法还是很简单的~毕竟只是基础的几个数据结构而已. Copyright © song_jx 2019 all right reserved，powered by Gitbook修订时间: 2019-06-22 23:01:58 "},"Chapter0/leetcode/0.2.1.html":{"url":"Chapter0/leetcode/0.2.1.html","title":"LeetCode","keywords":"","body":"排序 1. 寻找两个有序数组的中位数. LeetCode 题目描述:给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 虽然标注的是困难,主要难度在O(log(m+n))的复杂度限制上,思路从暴力解到归并排序再到官方的题解... 先利用归并排序吧,很容易就能想到利用归并排序的,毕竟有关键字两个有序数组 实现如下,基本上和之前基础部分的归并排序部分没什么区别,只需要把中间的数字返回就可以了. public double findMediaSortedArrays(int[] nums1, int[] nums2) { int total = nums1.length + nums2.length; int[] array = new int[total]; int i = 0, j = 0, k = 0; //开始归并 while (i nums2[j]) { array[k++] = nums2[j++]; } else { array[k++] = nums1[i++]; array[k++] = nums2[j++]; } } //数组可能长度不同,所以再将多出来的部分归并 while (i 应该没什么好说明的...只要懂归并排序的原理就能写出来... 下回提到这个算法的话会改进到官方要求的复杂度. PS:挑这个算法只是单纯因为快考试了...没太多时间想如何解释别的算法23333挑了个比较好写的...hhhhh Copyright © song_jx 2019 all right reserved，powered by Gitbook修订时间: 2019-06-22 23:01:58 "},"Chapter1/":{"url":"Chapter1/","title":"Java","keywords":"","body":"Java Copyright © song_jx 2019 all right reserved，powered by Gitbook修订时间: 2019-06-22 23:01:58 "},"Chapter1/1.1.html":{"url":"Chapter1/1.1.html","title":"第1节: 环境配置","keywords":"","body":"第1节: 环境配置 我们需要配置下列环境...虽然我给你配过了,不过万一你删掉了或者不好使了,还能看着重来一遍~ Java环境 Maven IDEA/如果之前安装好的被删了的话,可以考虑使用VSCode Java环境 Java SE Java SE 8官方链接,或许某一天可能就变了,所以最好百度搜Java SE 点击Accept License Agreement,然后下载最下面的Windows x64对应的jdk 一步步安装就可以了. 然后打开控制面板->系统和安全->系统->高级系统设置->环境变量. 系统变量中添加 变量名 变量值 JAVA_HOME C:\\Program Files\\Java\\jdk1.8.0_181 (这里根据自己实际安装的jdk地址) Path(该变量通常是已经存在的) %JAVA_HOME%\\bin Path %JAVA_HOME%\\jre\\bin CLASSPATH(该变量通常存在) %JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar; (添加到末尾) 其中dt.jar是运行环境是用到的类库,tools.jar是使用javac命令进行编译时需要的Java工具. 这些环境变量其实就是告诉Windows,在你使用命令时对应到哪个目录去找该命令对应的工具,当然这些环境变量只有在使用命令行工具的时候才会派上用处,比如cmd,powershell.如果使用IDEA就不需要配这个...但是为了后续内容,还是需要用到命令行工具的. 配好后打开cmd或者powershell,分别输入命令:java -version和javac -version 如果为如图结果,则环境变量配置好了,如果不行首先重启,再试试. 还不可以就检查自己的目录是否输入正确,有没有缺分号,检查jdk/lib目录下是否存在dt.jar和tools.jar Maven Maven是一个包管理工具,同时它可以批量打包编写好的Java文件,发布到中央仓库... 简单说Maven是一个应用商店,可以通过输入名称来下载对应的Java应用程序. Maven 官方下载地址 点击画圈部分下载,可能有些慢...稍微等等.然后解压到一个目录下. 继续添加系统环境变量,找到Path,添加如下 C:\\Users\\sakur\\AppData\\Local\\Maven\\apache-maven-3.6.0\\bin 也就是解压后文件中的bin所在的目录 在cmd中输入mvn -v 这样Maven就配置完成了~ 然后打开apache-maven-3.1.0/conf目录下的setting.xml 找到mirrors这一行部分,然后复制以下内容,结果如图就可以了 alimaven aliyun maven https://maven.aliyun.com/repository/central central 不配置这个的话...下载java包会比较慢...这个是使用阿里的应用镜像 然后再快结束的地方找到这个对应的地方,复制粘贴如下代码,结果如图就可以 development 1.8 true 1.8 1.8 1.8 这个是告诉Maven默认我们的Java版本,和生成的结果版本,因为我们使用的是Java SE8,是1.8版本. IDEA 我记得应该给你下载过了吧...如果你删掉了......唉...我也不晓得网上现在的破解方法好不好使...如果有学校的学生邮箱的话就比较好解决了~可以免费用到毕业~ IDEA 学生认证 JetBrains 这个是ToolBox...可以在里面下载常用的IDE,它家的IDE都很好用 后续可能会用到Android Studio进行手机软件的开发. 认证你的学生邮箱就可以了,咱学校的学生邮箱海大在线应该就能看的吧,账号是学号,密码是海大在线的密码... 如果不行,或者你觉得麻烦的话...你可以私聊我用我的证书来正版验证.或者我帮你远程协助安装... 不过还是要有一点折腾精神的嘛~如果这点就嫌麻烦了的话...编程麻烦事还有好多好多的不管是前端后端还是测试... 打开IDEA,我们设置一些东西. 点击这个Other Settings...不然每次新项目都得重新设置. 搜索encoding,将其中的内容都改成UTF-8 搜索maven,将home directory改成刚才解压的哪个目录. 这样就算配置完了~ 如无特殊情况以后就再也不需要碰环境配置的问题了. Copyright © song_jx 2019 all right reserved，powered by Gitbook修订时间: 2019-06-22 23:01:58 "},"Chapter1/1.2.html":{"url":"Chapter1/1.2.html","title":"第2节: 基础语法","keywords":"","body":"第2节: 基础语法 Hello World 我们先使用VSCode吧...小程序使用VSCode写起来更方便点,IDEA打开就要好久... 打开VSCode,在拓展中搜索Java 安装该拓展就可以了,然后会提示重新加载.点一下等它重新加载就ok. 我们找一个目录用来放Java程序吧 我就放在这里了,然后右键打开VSCode 创建Hello.java,在其中输入如下内容 public class Hello { public static void main(String[] args) { if (args.length != 0) { for (String arg : args) { System.out.print(arg + \" \"); } } else { System.out.println(\"hello world\"); } } } 解释下代码 public static void main(String[] args) 每个编程语言写的程序都要有一个入口对吧~这句话就像C语言的void main()或者int main(),是一个约定俗成的写法... 为什么要加static?学JSP和C#的时候还是记得的吧,要使用一个类的方法必须先使用new创建该类的一个实例后调用,而static声明的变量和方法是不需要实例也可以使用的...而作为一个程序的入口,自然是要求不用实例也可以使用的,所以是用static声明的... 至于(String[] args ?)我们先运行一下试试吧~ 在VSCode的终端中输入javac Hello.java javac Hello.java java Hello java Hello 你好 世界 第一句话是将java文件编译成字节码文件,也就是后缀为class的那个. 第二句话是运行该字节码文件,使用java命令. 第三句话我们在后面增加了两个字符串\"你好\"和\"世界\" 可以看到输出了你好 世界... 现在我们再回头看看我们编写的main方法 public static void main(String[] args) { if (args.length != 0) { for (String arg : args) { System.out.print(arg + \" \"); } } else { System.out.println(\"hello world\"); } } 我们在终端中输入的变量会赋值给args这个字符串列表,所以我们可以直接通过args访问到我们终端中输入的数据. 然后我们判断有没有从终端中输入数据,如果输入了就遍历这个列表,并打印到终端上显示出来.没有输入就打印我们默认的hello world. 这样就介绍完了一个最基本的Java程序的构成. 然后我们整理一下程序目录... 在Hello.java第一行增加内容package basic; 然后创建目录basic,将Hello.java放进去,之前的Hello.class删掉. 解释下package是什么意思: package是一个类似命名空间的东西,想一想世界上每天产出那么多Java程序,不可能没有名字相同的Java类吧?那么它们用什么区分呢?答案就是用包名(package)区分.package约定俗成是使用域名的倒序来书写,比如说www.baidu.com,那么package就应该是com.baidu.www类似这样子的...那么在不同package引用的话只需要import引入完整的类路径就可以使用了...比如我们的Hello,就需要使用import basic.Hello;来进行引入. 如果不写package,那么在不同package中的类是没法import的噢~ 总结下都有什么: Java的入口方法public static void main(String[] args)详解 通过终端命令进行java程序编译及运行 了解package的使用 接下来要写~是关于面向对象和面向接口编程. Copyright © song_jx 2019 all right reserved，powered by Gitbook修订时间: 2019-06-23 13:11:38 "},"Chapter1/basic/mind/":{"url":"Chapter1/basic/mind/","title":"Java编程思想","keywords":"","body":"Java编程思想 Copyright © song_jx 2019 all right reserved，powered by Gitbook修订时间: 2019-06-22 23:01:58 "},"Chapter1/basic/mind/1.2.1.html":{"url":"Chapter1/basic/mind/1.2.1.html","title":"面向对象","keywords":"","body":"面向对象 Java的基本语法没什么好直接声明的,所以直接用实例来穿插着写一些可能以前没接触到的语法... 封装 封装可以被认为是一个保护屏障，防止该类的代码和数据被其它类的代码任意读取和修改。 先编写一个能获取名字和年龄的Person类 public class Person{ public String name; public int age; } 嗯,然后使用的时候可以这样写 public static void main(String[] args){ Person person = new Person(); person.name=\"陈\"; person.age=20; } 我们可以直接设置name的值,也可以直接获取age的值.然而经过几个版本的迭代后,我们不希望名字长度大于4个,我们也不希望age大于110岁,所以我们如下修改了Person. public class Person { private String name; private int age; public void setName(String name) throws Exception { if (name.length() > 4) { throw new Exception(\"name's length can't bigger than 4\"); } this.name = name; } public String getName() { return name; } public void setAge(int age) throws Exception { if (age > 110) { throw new Exception(\"age can't bigger than 110\"); } this.age = age; } public int getAge() { return age; } } 在name长度大于4和age大于110的时候抛出异常. 习惯上将这类set和get方法称为setter和getter. 因为我们用private限制了别的类访问name和age,所以它们只能通过getter和setter来设置和获取age. 这样就能确保我们一定会检验name和age是否合法(合乎我们的规定) 不过如果我们一开始将name和age设置为public的话,别人使用的时候就是直接通过person.name=\"\"这样的方式来设置和获取变量值,当我们将name设置为private后,以前的代码就无法编译通过了,它们必须重新编写代码将name改为setName或者getName(). 如果我们一开始就使用private限制访问,并根据需求增加了getter和setter方法,那么就不会需要别人每个地方都修改了. 所以习惯上,会在一开始就将这类变量设置为private,并根据需求增加它们的getter和setter方法. 比如某些变量不希望别人修改,但可以让他们看到,就只增加getter方法就可以了. 封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。 比如我们修改了setName,而调用的时候则不需要修改person.setName(); 多态 继承就不写了...简单写一点多态吧...平时也接触过很多多态的用法. 多态嘛,字面意思上看就是多种状态.在Java里有两种方法实现多态,分别是重载和重写. 重载很简单,就是只有参数的个数或者类型不尽相同的Java方法. public class Animal{ public void run(){ sout(\"running\"); } public void run(String animal){ sout(animal+\"running\"); } } 使用的时候 Animal animal = new Animal(); animal.run(); animal.run(\"cat\"); 会根据所给参数的不同选择对应的方法... 重写就是通过继承或者实现接口的方式,将父类或接口中的方法重新实现一遍,以下是重写的简单实现 public interface Animal{ void run(); } public class Cat implements Animal{ @Override public void run(){ sout(\"Cat run\"); } } public class Dog implements Animal{ @Override public void run(){ sout(\"dog run\"); } } 使用的时候 public class Main{ public static void main(String[] args){ Animal cat = new Cat(); Animal dog = new Dog(); cat.run(); dog.run(); } } 通过继承父类是类似的. 虽然cat和dog都是Animal类型的,但是因为它们run方法的实现是不同的,所以实际控制台打印出来的字符串是不一样的. 不过话说我刚学的时候觉得这样写有什么意义呢...为什么变量类型不直接声明成Cat或者Dog呢?非要声明为Animal来体现多态...而且实际上类的实例也是Cat实例和Dog实例...感觉多态也没什么神奇的啊... 这几个月写下来...这样的疑问减少了很多...所以,多敲代码,多用一用...随着代码量的增加和对面向对象的理解,自然就会知道这样写有什么好处... Copyright © song_jx 2019 all right reserved，powered by Gitbook修订时间: 2019-06-23 13:16:27 "},"Chapter1/basic/mind/1.2.2.html":{"url":"Chapter1/basic/mind/1.2.2.html","title":"面向接口","keywords":"","body":"面向接口 Copyright © song_jx 2019 all right reserved，powered by Gitbook修订时间: 2019-06-22 23:01:58 "},"Chapter1/basic/mind/1.2.3.html":{"url":"Chapter1/basic/mind/1.2.3.html","title":"函数式编程","keywords":"","body":"函数式编程 函数大概是小学还是初中学的吧... Copyright © song_jx 2019 all right reserved，powered by Gitbook修订时间: 2019-06-23 13:23:29 "},"Chapter1/1.3.html":{"url":"Chapter1/1.3.html","title":"第3节: 高级语法","keywords":"","body":"第3节: 高级语法 Copyright © song_jx 2019 all right reserved，powered by Gitbook修订时间: 2019-06-22 23:01:58 "},"Chapter2/":{"url":"Chapter2/","title":"Spring","keywords":"","body":"Spring Copyright © song_jx 2019 all right reserved，powered by Gitbook修订时间: 2019-06-22 23:01:58 "},"Chapter2/1.1.html":{"url":"Chapter2/1.1.html","title":"Spring环境","keywords":"","body":"Spring环境 Maven项目 我们使用maven来管理Java程序. maven之前有介绍过,相当于一个应用商店,你可以把它上面有的软件根据名字来下载到自己的项目里使用,同时也可以把自己的应用打包发布到maven的仓库里让别人来使用... VSCode 使用VSCode创建一个maven项目,流程如下: 打开VSCode,按下F1,搜索java overview 点击画圈部分,创建一个Maven项目. 选择一个原型,我们选择第三个jdk8就ok 然后会提示选择一个目录 会提示输入groupid,artifactid,version,package,根据自己喜好选择. 最终是这么一个目录. IDEA 可以选择使用IDEA,在新建项目中选择Maven 选择原型quickstart就可以了...之后是groupid和artifactid的填写... 两个工具创建的最终效果是一样的...因为IDEA更好用所以后续就用IDEA写了... 首先将pom.xml里的东西只留下如图部分. 不过其实properties里的东西也可以删掉的,因为之前在配置Java环境的时候已经把maven项目的默认编译版本都设置为Java 1.8了.不过我这里还是显式地留了下来. 然后我们百度maven repository,搜索spring-context...这个程序是spring环境的一个小集成 在下面的compile dependencies中可以看到大部分都是optional.翻到下面可以看到有四个不是可选的 分别是spring-aop,spring-beans,spring-core,spring-expression.这些我们之后或多或少都会用到. 我们把maven中那一串拷贝下来放到pom.xml的dependencies中 IDEA会提示让你import,导入后等它下载完成,应该就能在右边的maven侧栏中看到已经有了那四个程序. 这样我们的基本Spring框架的环境就搭建好了~使用maven可以简化很多我们的程序开发... 在没有maven的时候,我们需要去对应程序的官网下载它们提供的.jar后缀的应用,下载到本地后挨个导入到自己的程序中. 而有了maven,我们只需要再pom.xml中声明我们需要的依赖,maven就会自动地帮我们下载好,并且添加到我们的应用程序中. 然后简单说明下Spring是什么. Spring简介 Spring核心是通过IoC来使Java程序解耦,可以更方便的进行单元测试和团队协作.那什么是IoC. IoC是inverse of control的简写,字面意思是控制反转... 比如说我们写的Sort排序程序.我们在使用的时候需要这样. public void useSort(){ int[] a = new int[]{1,3,2,5,4}; Sort sort = new BubbleSort(); sort.sort(a); } 那么很容易就可以想到在进行单元测试的时候我们不可避免地在测试useSort()方法地同时,也会测试到BubbleSort()方法,我们可能不想在测试的时候碰到这种强依赖的情况,在不看源代码的情况下你也不会知道这个方法强依赖BubbleSort(). 并且这里的使用Sort方法都写死了为冒泡排序,我们如果想要更换排序方法得自己修改这里的代码,在团队协作的时候很不方便,如果这个useSort()是其它人写的,你需要修改别人的方法.而你又对它的代码不是很了解,可能不小心改错了什么的...因此我们需要解耦. 现在这个useSort()方法是强依赖BubbleSort()类的,我们将它修改修改. public class Test{ Sort sort; public Test(Sort sort){ this.sort=sort; } public void useSort(){ int[] a = new int[]{1,2,4,2,3}; sort.sort(a); } } 这样就将两个类进行了解耦,我们在创建这个Test实例的时候,利用构造方法传入一个Sort实例,在Test内部是没有实例化其他类的.当然这里除了这个int[] a,不过这个int[] a也是可以用这种方式就行解耦的,不过就目前而言没什么必要而已2333毕竟只是一个简单的示例,你也可以把int[] a利用这种方式来进行解耦. 我们在单元测试的时候,将我们已经测试好的类实例化,然后传给这个Test就可以了,如下代码 public static void main(String[] args){ Sort sort = new MergeSort(); Test test = new Test(sort); test.useSort(); } 跟之前的写法有些许不同对吧... 那么什么是控制反转呢?在最初我们写的有强依赖的类中,我们是自己实例化了一个Sort来使用. 在后来解耦的这个版本,我们是在类的构造方法里声明了我们需要一个Sort类型的实例,然后由调用者来自己决定传哪一个Sort实例给我们. 本来我们依赖的类是我们自己用new关键字实例化的,控制反转则是告诉别人我们需要这个类的实例,你给我传进来让我用. 这就是Spring的核心控制反转. 控制反转同时也叫做依赖注入,这两个是一个东西的根据不同的理解所得到的不同称呼而已. 依赖注入就很好理解了嘛,我们把一个类的实例注入到另一个需要它的类中~ 那么Spring是什么呢? 我们先简单写一个例子吧~先创建一个SpringConfig类,在上面增加两个注解@Configuration和@ComponentScan package com.dlmu; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; @Configuration @ComponentScan public class SpringConfig { } 这样就可以了. 然后我们创建几个简单的类用来测试. import org.springframework.stereotype.Component; @Component public class Animal { public void run(){ System.out.println(\"animal can run\"); } } import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class World { @Autowired private Animal animal; public void have() { animal.run(); } } 创建了三个类,其中一个为Animal,一个为World. 之前在解耦的时候我们手动在调用的时候用new实例化一个类并且进行了注入,而Spring会帮我们进行类的实例化和注入.简单看下代码. 其中被@Component标识的类会被Spring管理,这样Spring就知道了这个类是需要它来进行管理的. 可以观察到我们在World中并没有使用new实例化一个对象,只是在成员变量上增加了@Autowired注解就直接使用了animal的方法.回过头看看我们的SpringConfig类 其中的 @Configuration注解声明该类为一个Spring配置类. @ComponentScan告诉Spring应该扫描哪些类.默认为该配置类所在包下的所有类. 现在普通地使用main方法是没有办法进行测试的,原因以后再写吧...现在只需要知道就好了... 我们使用Spring提供的spring-test和junit来进行测试. 同样的在maven里搜spring-test和junit,并添加到pom.xml中. 最终如下. org.springframework spring-context 5.1.8.RELEASE org.springframework spring-test 5.1.8.RELEASE test org.junit.jupiter junit-jupiter-api 5.5.0-RC2 test 然后我们修改test目录下的AppTest类如下 package com.dlmu; import org.junit.jupiter.api.Test; import org.junit.jupiter.api.extension.ExtendWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.test.context.junit.jupiter.SpringExtension; import org.springframework.test.context.junit.jupiter.SpringJUnitConfig; @ExtendWith(SpringExtension.class) @SpringJUnitConfig(SpringConfig.class) public class AppTest { @Autowired private World world; @Test void test() { world.have(); } } ExtendWith注解是Junit提供给我们的,它告诉Junit我们使用了Spring. 下面的是Spring-test提供的注解,它告诉spring-test我们的配置文件是哪个. 我们点击绿色箭头运行下~ 可以看到我们没有使用任何new来创建实例,但是整个程序却跑起来了~ 这就是Spring最核心的部分. 所有被Spring管理的类被称作bean,也就是之前我们使用Component注解标识的类,当然SpringConfig和AppTest也是bean,它们也被Spring管理. 我们可以在SpringConfig类中来配置该如何生成一个类的实例,不过目前我们使用@Component进行了自动装配bean,而没有自定义配置. 所以回头想想spring-context中的四个依赖,其中两个我们已经用上了,spring-core和spring-bean. spring-bean就是管理所有的bean,所有的bean都有生命周期,而不是说从应用程序开始就实例化,然后到结束才销毁这么简单. spring-core自然就是依赖注入的部分了~ 剩下两个依赖在接下来会慢慢都用到的~目前先就这些了~ Copyright © song_jx 2019 all right reserved，powered by Gitbook修订时间: 2019-06-23 23:02:23 "},"Chapter3/":{"url":"Chapter3/","title":"Servlet","keywords":"","body":"Servlet Copyright © song_jx 2019 all right reserved，powered by Gitbook修订时间: 2019-06-22 23:01:58 "},"Chapter4/":{"url":"Chapter4/","title":"Spring-MVC","keywords":"","body":"Spring-MVC Copyright © song_jx 2019 all right reserved，powered by Gitbook修订时间: 2019-06-22 23:01:58 "},"Chapter5/":{"url":"Chapter5/","title":"Spring-Boot","keywords":"","body":"Spring-Boot Copyright © song_jx 2019 all right reserved，powered by Gitbook修订时间: 2019-06-22 23:01:58 "},"Chapter6/":{"url":"Chapter6/","title":"Spring-Cloud","keywords":"","body":"Spring-Cloud Copyright © song_jx 2019 all right reserved，powered by Gitbook修订时间: 2019-06-22 23:01:58 "}}