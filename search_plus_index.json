{"./":{"url":"./","title":"前言","keywords":"","body":"Introduction emmm...因为之前的项目太乱了...所以想着重构一下,重新整理一下,顺便发布到GitHub提供的静态网页上,这样能有更好的浏览体验吧,然后把每个部分的示例代码都分开,不要在一份代码上迭代,应该能看得更明白点...点击上面的阅读按钮就可以访问到一个还算漂亮的文档了~ 计划 简单写些本文档计划写的东西吧. 首先是Java自身的一些语法特性,我们平常使用的Java环境是Java SE,也就是Standard Edition标准版. 然后是Java EE,Java EE就是的Java企业版DLC,在Java SE上又增加了一些企业版开发所需要的类库,比如众所周知的Servlet,JSP,JDBC,JPA等等 接着是Spring全家桶. 会穿插在其中写一些流行的工具的使用方法,比如Redis/非关系型数据库,RabbitMQ/消息队列. 如果有时间还会写一些前端的部分. 还有计算机最重要的东西!数据结构和算法...每天会更新至少一道算法题吧,目前我是希望能做到的...刚开始希望能更新多点~ 我的看法 编程语言 关于我对编程的看法... 我觉得最重要的是,不要让编程语言成为自己的限制. 至少我会用的编程语言...TypeScript,JavaScript,Dart,Java,Bash,Python...当然我大部分只是知道语法,简单用来做过一些自己觉得好玩的小东西.我记得我Dart大概是一个多小时看完语法然后开始做Flutter的. 所以我觉得编程并不是学习编程语言,编程语言没什么好学的,要学的是它解决问题的方向,以及为了解决这个方向上的问题所提供的生态环境. 现今流行的编程语言,基本都是为了简单好用而开发出来的,不存在什么学习难度. 所有的当今编程语言的最基本构成是: 循环 条件 也就是流程控制,只要会控制程序运行的流程,就能配合生态做几乎所有的事了. 比如现在流行的是Python,那么Python目前流行的方向是什么?人工智能,科学计算,大数据,算法之类的. Python是众说周知地简单,你见过有人说Python难的吗?那为什么Python工资高?解决的问题应该和它的高薪所匹配,所以难的是它解决问题的方向,难在人工智能,科学计算上.而不是语言本身的难度带给它价值. 学习编程,更多的是学习编程语言对应的方向生态环境. 学习JavaScript,CSS,HTML,对应的是根据设计师提供的图来实现对应的网页效果. 学习Java,对应的是Web后端服务器的各种业务问题的解决与优化. 学习Python,对应人工智能,科学计算,也可以用于快速解决并不复杂的问题. 学习C语言,对应的是嵌入式开发 学习C#,对应的微软的生态. 编程语言是为了解决一个方向上的问题而诞生的,解决问题的方法是一系列算法组合成的,而为了让自己写出的算法有最大的性能表现,所以又有各种数据结构,每种数据结构所适应的算法是不同的. 毕竟编程的本质就是01010101嘛,再复杂的程序也不过是各种数据构成的...所以算法和数据结构是编程最重要的部分. 大部分的编程语言的语法,都是很简单的,不会浪费太多时间,有一定数据结构和算法的能力,学习编程不过水到渠成.所以我真的希望...不要因为觉得轻松去学测试...如果是为了轻松无聊而选择测试,那是没有一点价值的...抱着这种心态选择测试...也不可能被大公司录用的即使条件比后端和前端都要低一些. 希望,不要得过且过... 后端 由于我目前打算学习的是后端,至于为什么学,自然是因为在工资上普遍比前端高,而更高的那些比如算法岗位,大部分都是需要研究生的...我目前没打算读研,所以暂时只能退而求其次选择后端.现在我对后端整体还是有所了解的.所以大概写一下需要学习的东西,算是一个大纲了. 我觉得不要从语法开始学,没有什么意义...直接去学生态环境,从生态开始一点点了解它的基础语法,一步步拓展对该语言的了解,了解该语言的特性. 所以我会按照下面的流程编写该文档. Java环境配置 Spring的基本使用 Java基本语法 Java设计模式 Servlet基本使用 Spring MVC的基本使用 Java高级语法/此高级非彼高级~ Spring Boot基本使用 Servlet拓展 Spring拓展 Spring MVC拓展 Spring Boot拓展 JVM虚拟机 Java多线程 Java网络编程 Spring Cloud/分布式 微服务 就这么些东西,中间会穿插着写一些别的东西,然后每天更新点算法/数据结构 我觉得暑假的两个月我是可以把这些都写完的~ 我个人的小小愿望...希望你能看完吧...... Copyright © song_jx 2019 all right reserved，powered by Gitbook修订时间: 2019-06-10 23:20:35 "},"LOG.html":{"url":"LOG.html","title":"更新日志","keywords":"","body":"更新日志 %accordion%2019/6/10%accordion% [!NOTE] 基础排序 选择排序 插入排序 希尔排序 Java基础 Java环境 Java基础语法 %/accordion% Copyright © song_jx 2019 all right reserved，powered by Gitbook修订时间: 2019-06-10 23:47:20 "},"Chapter0/":{"url":"Chapter0/","title":"Algorithms","keywords":"","body":"Algorithms 该算法部分设定下分为以下几部分 基础部分 排序 数据结构 进阶部分 进阶部分基本上为从LeetCode上摘录的算法原题的题解. 加上一些我自己理解的解释. 示例代码项目所在目录为 Algorithms Copyright © song_jx 2019 all right reserved，powered by Gitbook修订时间: 2019-06-11 16:44:14 "},"Chapter0/basic/":{"url":"Chapter0/basic/","title":"基础算法","keywords":"","body":"基础算法 Copyright © song_jx 2019 all right reserved，powered by Gitbook修订时间: 2019-06-11 16:15:19 "},"Chapter0/basic/1.1.1.html":{"url":"Chapter0/basic/1.1.1.html","title":"排序","keywords":"","body":"排序 首先根据面向接口编程的思想,定义一个接口Sort package basic.sort; public interface Sort { void sort(int[] a); } 很简单,只包含一个排序方法sort 点击标题查看实例代码. 冒泡排序 package basic.sort; public class Bubble implements Sort { @Override public void sort(int[] a) { //i来判断进行了几轮排序,最大轮次=数组长度-1 for (int i = 0; i a[j + 1]) { int temp = a[j]; a[j] = a[j + 1]; a[j + 1] = temp; } } } } } 冒泡算法是最基础的算法,应该注释就够了,原理的话: 网上找到的容易看懂的图. 只比较相邻的元素,如果相邻元素的顺序相反的话就交换,一直将该轮次的数字交换到正确的位置. 因为数字是依次向上冒头,或许看着像冒泡吧...所以叫冒泡排序... 选择排序 package basic.sort; public class Selection implements Sort { @Override public void sort(int[] a) { //用i索引当前排序到第几个位置 for (int i = 0; i 简单说明一下选择排序吧 利用一个临时变量min,将目前遇到的最小的数字的索引位置存起来,如果碰到比该数字小的,就交换这两个数字的位置. 然后创建一个Main方法用来测试我们写好的排序. import basic.sort.Sort; import basic.sort.Selection; import java.util.Arrays; public class Main { public static void main(String[] args) { Sort sort = new Shell(); int[] a = new int[] { 2, 5, 4, 1, 3 }; sort.sort(a); System.out.println(Arrays.toString(a)); } } 在终端执行命令 javac Main.java java Main 对了,如果java文件中有中文注释,需要声明用-encoding utf-8进行编译,不然会出现编码错误. 所以如果有中文注释,我们显式用该命令编译 javac -encoding UTF-8 Main.java 目前目录状况如下. 接下来就不一一赘述这些东西了...详情参考示例代码. 插入排序 import basic.sort.Sort; public class Insertion implements Sort { @Override public void sort(int[] a) { //i表示当前有几个数字是有序的 for (int i = 1; i 0; j--) { //如果j的前一个比j小,就将它插到前面. if (a[j - 1] > a[j]) { int temp = a[j]; a[j] = a[j - 1]; a[j - 1] = temp; } } } } } 看着好像比选择排序还简单的样子233333 不过实际上效率要高出很多...简单说明: 对比从a[i]到a[0]之间的数字,如果a[i-1]>a[i],就交换顺序,每次只挪动一个位置.遍历一遍后依次将数字移动到正确的位置就可以了. 测试的时候将Main方法里的new Selection()修改为new Insertion()就可以了 希尔排序 希尔排序/Shell Sort是插入排序的改良版. 在观察插入排序的时候,每次都只交换一个位置,可能要交换很多次才能到正确的地方.那么我们就考虑尽可能地将它挪动到最远的地方. 在这里给出一个概念吧...2-有序,4-有序,8-有序的意思是,每隔x个的数字是有序的,至于x之间的数字则先不考虑...比如这个数组 2,1,4,3,6,3,8,1,10 这个就是一个2-有序数组,因为2,4,6,8,10是有序的. 所以我们就考虑利用插入排序,每次不止挪动一个位置,而是x个位置,先让它变成x-有序就可以了.所以有如下实现 package basic.sort; public class Shell implements Sort { @Override public void sort(int[] a) { int N = a.length; int h = 1; //设置一个数字,表示每次挪动h个位置,希尔排序的性能取决于该数字的算法. //简单起见我只是将该数字设置小于length的最大2^n while (h = 1) { //下面类似插入排序了,只是每次如果需要插入,则直接插入到前面h个位置的地方 for (int i = h; i = h; j -= h) { if (a[j] 参考如上.我们先构造了一个尽可能大的数字,比如这里我们利用循环构造了一个数字2^n 比如length长度为20,那么h就是16,然后第一遍循环先看第16个数字跟第一个数字的大小,视情况交换,然后j=j-h...然后比较a[17]和a[1]...... 第一遍结束后应该是个16-有序数组,然后让h=h/2,让这个数组变为8-有序,4-有序,2-有序,1-有序... 1-有序自然就是一个常规的有序列表了 还是很简单的... 归并排序 我们先写归并排序的原理吧: 归并排序是将两个有序数组归并为一个有序数组的算法,也就是说必须提供给它两个有序数组. 我们根据这个思路先将归并的算法写出来,然后再考虑两个数组不是有序的情况. package basic.sort; public class Merge implements Sort { public int[] merge(int[] a, int[] b) { //新建一个数组,用来存放归并后的结果 int[] result = new int[a.length + b.length]; //i表示当前归并到第一个数组的第i个位置 //j表示归并到第二个数组的第j个位置 //k表示归并到结果数组的第k个位置 int i = 0, j = 0, k = 0; while (i b[j]) { result[k++] = b[j++]; } else { result[k++] = a[i++]; result[k++] = b[j++]; } } //这两个循环是可能存在两个数组长度不相等的情况. while (i 这是提供两个有序数组时候的算法.不算难,那么考虑下如何利用该算法将一个无序数组归并为一个有序数组? 首先我们想想如何在一个数组中进行归并,我们可以人为的利用一个变量将一个数组分为两个,比如mid表示中间,将mid左右两边的数字分别利用上面的思路归并. 然后我们实现另一种归并算法 public int[] merge(int[] a) { int mid = a.length / 2; int[] result = new int[a.length]; //i表示数组左半边归并到第i个位置 //j表示数组右半边归并到第i个位置 //k表示结果数组归并到的位置 int i = 0, j = mid + 1, k = 0; for (; k mid,说明左半边归并结束了,但是右半边还存在没有数组归并到结果中 if (i > mid) result[k] = a[j++]; //同上一个判断. else if (j > hi) result[k] = a[i++]; //将较小的放到结果数组中. //其中相等的情况我们利用上面两个判断进行了归并,所以这里并不需要再进行多余的判断了 else if (a[j] 那么继续思考,怎么在两边都无序的情况下归并呢? 简单想想,我们可以利用递归.为什么利用递归呢? 如果数组中只有2个数字,那么左右半边两边是不是有序的呢? 如果数组中有4个数字,我们可以拆分为左右两个2个数字的数组对吧? 那么把左右两个数组排序好了后,这个4个数字的数组是不是就存在两个有序数组呢? 所以可以利用递归,从2个长度的数组开始归并,一直归并到整个数组就结束. 那么有如下的完整实现. public class Merge implements Sort { //我们声明一个临时变量,用来存放需要排序的数组,将结果放在原数组中 //可以避免我们利用return来返回result结果 private int[] aux; @Override public void sort(int[] a) { //实例化临时变量为排序数组的长度 aux = new int[a.length]; //利用另一个方法进行数组的递归拆分操作. //所以要先将排序数组完整的传给该方法. sort(a, 0, a.length - 1); } //用来递归拆分数组的排序方法. //lo表示数组的最低边界,hi表示数组的最高边界. private void sort(int[] a, int lo, int hi) { //最低边界大于最高边界,就返回. if (hi mid) a[k] = aux[j++]; else if (j > hi) a[k] = aux[i++]; else if (aux[j] 归并排序算法到这里就结束了~里面涉及的东西还是挺多的...我觉得这里开始排序算法才有一定难度了.递归这里如果不深入思考的话也是挺难想到如何实现的... 首先归并排序在数组长度较小时效率并不高,可以看到我们进行了很多的循环,但是在数组长度过长的时候可能就会有栈溢出报错的情况,所以递归实现并不算是一个最优解... 我们数据结构与算法中学习过如何将递归改造为栈,所以我们是可以通过一个栈的数据结构将递归进行改造,在随后有机会会进行改进. 至于优化归并排序本身性能的话,可以考虑在递归进行归并的时候,如果数组长度较小,也就是hi-lo比较小的时候,可以利用插入排序,插入排序在数组长度较小时是一个很好用的排序算法. Copyright © song_jx 2019 all right reserved，powered by Gitbook修订时间: 2019-06-11 16:46:44 "},"Chapter0/basic/1.1.2.html":{"url":"Chapter0/basic/1.1.2.html","title":"数据结构","keywords":"","body":"数据结构 Copyright © song_jx 2019 all right reserved，powered by Gitbook修订时间: 2019-06-11 16:15:19 "},"Chapter1/":{"url":"Chapter1/","title":"Java","keywords":"","body":"Java Copyright © song_jx 2019 all right reserved，powered by Gitbook修订时间: 2019-06-11 16:15:19 "},"Chapter1/1.1.html":{"url":"Chapter1/1.1.html","title":"第1节: 环境配置","keywords":"","body":"第1节: 环境配置 我们需要配置下列环境...虽然我给你配过了,不过万一你删掉了或者不好使了,还能看着重来一遍~ Java环境 Maven IDEA Java环境 Java SE Java SE 8官方链接,或许某一天可能就变了,所以最好百度搜Java SE 点击Accept License Agreement,然后下载最下面的Windows x64对应的jdk 一步步安装就可以了. 然后打开控制面板->系统和安全->系统->高级系统设置->环境变量. 系统变量中添加 变量名 变量值 JAVA_HOME C:\\Program Files\\Java\\jdk1.8.0_181 (这里根据自己实际安装的jdk地址) Path(该变量通常是已经存在的) %JAVA_HOME%\\bin Path %JAVA_HOME%\\jre\\bin CLASSPATH(该变量通常存在) %JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar; (添加到末尾) 其中dt.jar是运行环境是用到的类库,tools.jar是使用javac命令进行编译时需要的Java工具. 这些环境变量其实就是告诉Windows,在你使用命令时对应到哪个目录去找该命令对应的工具,当然这些环境变量只有在使用命令行工具的时候才会派上用处,比如cmd,powershell.如果使用IDEA就不需要配这个...但是为了后续内容,还是需要用到命令行工具的. 配好后打开cmd或者powershell,分别输入命令:java -version和javac -version 如果为如图结果,则环境变量配置好了,如果不行首先重启,再试试. 还不可以就检查自己的目录是否输入正确,有没有缺分号,检查jdk/lib目录下是否存在dt.jar和tools.jar Maven Maven是一个包管理工具,同时它可以批量打包编写好的Java文件,发布到中央仓库... 简单说Maven是一个应用商店,可以通过输入名称来下载对应的Java应用程序. Maven 官方下载地址 点击画圈部分下载,可能有些慢...稍微等等.然后解压到一个目录下. 继续添加系统环境变量,找到Path,添加如下 C:\\Users\\sakur\\AppData\\Local\\Maven\\apache-maven-3.6.0\\bin 也就是解压后文件中的bin所在的目录 在cmd中输入mvn -v 这样Maven就配置完成了~ 然后打开apache-maven-3.1.0/conf目录下的setting.xml 找到mirrors这一行部分,然后复制以下内容,结果如图就可以了 alimaven aliyun maven https://maven.aliyun.com/repository/central central 不配置这个的话...下载java包会比较慢...这个是使用阿里的应用镜像 然后再快结束的地方找到这个对应的地方,复制粘贴如下代码,结果如图就可以 development 1.8 true 1.8 1.8 1.8 这个是告诉Maven默认我们的Java版本,和生成的结果版本,因为我们使用的是Java SE8,是1.8版本. IDEA 我记得应该给你下载过了吧...如果你删掉了......唉...我也不晓得网上现在的破解方法好不好使...如果有学校的学生邮箱的话就比较好解决了~可以免费用到毕业~ IDEA 学生认证 JetBrains 这个是ToolBox...可以在里面下载常用的IDE,它家的IDE都很好用 后续可能会用到Android Studio进行手机软件的开发. 认证你的学生邮箱就可以了,咱学校的学生邮箱海大在线应该就能看的吧,账号是学号,密码是海大在线的密码... 如果不行,或者你觉得麻烦的话...你可以私聊我用我的证书来正版验证.或者我帮你远程协助安装... 不过还是要有一点折腾精神的嘛~如果这点就嫌麻烦了的话...编程麻烦事还有好多好多的不管是前端后端还是测试... 打开IDEA,我们设置一些东西. 点击这个Other Settings...不然每次新项目都得重新设置. 搜索encoding,将其中的内容都改成UTF-8 搜索maven,将home directory改成刚才解压的哪个目录. 这样就算配置完了~ 如无特殊情况以后就再也不需要碰环境配置的问题了. Copyright © song_jx 2019 all right reserved，powered by Gitbook修订时间: 2019-06-11 16:15:19 "},"Chapter1/1.2.html":{"url":"Chapter1/1.2.html","title":"第2节: 基础语法","keywords":"","body":"第2节: 基础语法 Hello World 我们先使用VSCode吧...小程序使用VSCode写起来更方便点,IDEA打开就要好久... 打开VSCode,在拓展中搜索Java 安装该拓展就可以了,然后会提示重新加载.点一下等它重新加载就ok. 我们找一个目录用来放Java程序吧 我就放在这里了,然后右键打开VSCode 创建Hello.java,在其中输入如下内容 public class Hello { public static void main(String[] args) { if (args.length != 0) { for (String arg : args) { System.out.print(arg + \" \"); } } else { System.out.println(\"hello world\"); } } } 解释下代码 public static void main(String[] args) 每个编程语言写的程序都要有一个入口对吧~这句话就像C语言的void main()或者int main(),是一个约定俗成的写法... 为什么要加static?学JSP和C#的时候还是记得的吧,要使用一个类的方法必须先使用new创建该类的一个实例后调用,而static声明的变量和方法是不需要实例也可以使用的...而作为一个程序的入口,自然是要求不用实例也可以使用的,所以是用static声明的... 至于(String[] args ?)我们先运行一下试试吧~ 在VSCode的终端中输入javac Hello.java javac Hello.java java Hello java Hello 你好 世界 第一句话是将java文件编译成字节码文件,也就是后缀为class的那个. 第二句话是运行该字节码文件,使用java命令. 第三句话我们在后面增加了两个字符串\"你好\"和\"世界\" 可以看到输出了你好 世界... 现在我们再回头看看我们编写的main方法 public static void main(String[] args) { if (args.length != 0) { for (String arg : args) { System.out.print(arg + \" \"); } } else { System.out.println(\"hello world\"); } } 我们在终端中输入的变量会赋值给args这个字符串列表,所以我们可以直接通过args访问到我们终端中输入的数据. 然后我们判断有没有从终端中输入数据,如果输入了就遍历这个列表,并打印到终端上显示出来.没有输入就打印我们默认的hello world. 这样就介绍完了一个最基本的Java程序的构成. 然后我们整理一下程序目录... 在Hello.java第一行增加内容package basic; 然后创建目录basic,将Hello.java放进去,之前的Hello.class删掉. 解释下package是什么意思: package是一个类似命名空间的东西,想一想世界上每天产出那么多Java程序,不可能没有名字相同的Java类吧?那么它们用什么区分呢?答案就是用包名(package)区分.package约定俗成是使用域名的倒序来书写,比如说www.baidu.com,那么package就应该是com.baidu.www类似这样子的...那么在不同package引用的话只需要import引入完整的类路径就可以使用了...比如我们的Hello,就需要使用import basic.Hello;来进行引入. 如果不写package,那么在不同package中的类是没法import的噢~ 总结下都有什么: Java的入口方法public static void main(String[] args)详解 通过终端命令进行java程序编译及运行 了解package的使用 接下来要写的就很跳跃了~是关于面向对象和面向接口编程.是编写面向对象语言的基本思想. Copyright © song_jx 2019 all right reserved，powered by Gitbook修订时间: 2019-06-11 16:15:19 "},"Chapter1/basic/1.2.1.html":{"url":"Chapter1/basic/1.2.1.html","title":"面向对象","keywords":"","body":"面向对象 Copyright © song_jx 2019 all right reserved，powered by Gitbook修订时间: 2019-06-11 16:15:19 "},"Chapter1/basic/1.2.2.html":{"url":"Chapter1/basic/1.2.2.html","title":"面向接口","keywords":"","body":"面向接口 Copyright © song_jx 2019 all right reserved，powered by Gitbook修订时间: 2019-06-11 16:15:19 "},"Chapter1/1.3.html":{"url":"Chapter1/1.3.html","title":"第3节: 高级语法","keywords":"","body":"第3节: 高级语法 Copyright © song_jx 2019 all right reserved，powered by Gitbook修订时间: 2019-06-11 16:15:19 "},"Chapter2/":{"url":"Chapter2/","title":"Spring","keywords":"","body":"Spring Copyright © song_jx 2019 all right reserved，powered by Gitbook修订时间: 2019-06-11 16:15:19 "},"Chapter3/":{"url":"Chapter3/","title":"Servlet","keywords":"","body":"Servlet Copyright © song_jx 2019 all right reserved，powered by Gitbook修订时间: 2019-06-11 16:15:19 "},"Chapter4/":{"url":"Chapter4/","title":"Spring-MVC","keywords":"","body":"Spring-MVC Copyright © song_jx 2019 all right reserved，powered by Gitbook修订时间: 2019-06-11 16:15:19 "},"Chapter5/":{"url":"Chapter5/","title":"Spring-Boot","keywords":"","body":"Spring-Boot Copyright © song_jx 2019 all right reserved，powered by Gitbook修订时间: 2019-06-11 16:15:19 "},"Chapter6/":{"url":"Chapter6/","title":"Spring-Cloud","keywords":"","body":"Spring-Cloud Copyright © song_jx 2019 all right reserved，powered by Gitbook修订时间: 2019-06-11 16:15:19 "}}