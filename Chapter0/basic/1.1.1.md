# 排序

首先根据面向接口编程的思想,定义一个接口Sort

```java
package basic.sort;

public interface Sort {
    void sort(int[] a);
}
```

很简单,只包含一个排序方法sort

## 选择排序

```java
package basic.sort;

public class Selection implements Sort {
    @Override
    public void sort(int[] a) {
        for (int i = 0; i < a.length; i++) {
            int min = i;
            for (int j = i + 1; j < a.length; j++) {
                if (a[j] < a[min]) {
                    min = j;
                }
            }
            if (min != i) {
                int temp = a[i];
                a[i] = a[min];
                a[min] = temp;
            }
        }
    }
}
```

简单说明一下选择排序吧,算是一个冒泡排序的优化版,减少了交换数字的次数.

利用一个临时变量min,将目前遇到的最小的数字的索引位置存起来,如果碰到比该数字小的,就交换这两个数字的位置.

与冒泡排序一样都是两层for循环嵌套.

然后创建一个Main方法用来测试我们写好的排序.

```java
import basic.sort.Sort;
import basic.sort.Selection;

public class Main {
    public static void main(String[] args) {
        Sort sort = new Selection();
        int[] a = new int[] { 2, 5, 4, 1, 3 };
        sort.sort(a);
        System.out.print("{");
        for (int i : a) {
            System.out.print(" " + i + " ");
        }
        System.out.print("}");
    }
}
```

在终端执行命令javac Main.java和java Main

![1560177808562](assets/1560177808562.png)

目前目录状况如下.

![1560177862132](assets/1560177862132.png)

接下来就不一一赘述这些东西了...详情参考示例代码.

## 插入排序

```java
import basic.sort.Sort;

public class Insertion implements Sort {
    @Override
    public void sort(int[] a) {
        for (int i = 1; i < a.length; i++) {
            for (int j = i; j > 0; j--) {
                if (a[j - 1] > a[j]) {
                    int temp = a[j];
                    a[j] = a[j - 1];
                    a[j - 1] = temp;
                }
            }
        }
    }
}
```

看着好像比选择排序还简单的样子233333

不过实际上效率要高出很多...简单说明:

对比从a[i]到a[0]之间的数字,如果a[i-1]>a[i],就交换顺序,每次只挪动一个位置.遍历一遍后依次将数字移动到正确的位置就可以了.

测试的时候将Main方法里的new Selection()修改为new Insertion()就可以了

## 希尔排序

希尔排序/Shell Sort是插入排序的改良版.

在观察插入排序的时候,每次都只交换一个位置,可能要交换很多次才能到正确的地方.那么我们就考虑尽可能地将它挪动到最远的地方.

在这里给出一个概念吧...2-有序,4-有序,8-有序的意思是,每隔x个的数字是有序的,至于x之间的数字则先不考虑...比如这个数组

>2,1,4,3,6,3,8,1,10

这个就是一个2-有序数组,因为2,4,6,8,10是有序的.

所以我们就考虑利用插入排序,每次不止挪动一个位置,而是x个位置,先让它变成x-有序就可以了.所以有如下实现

```java
package basic.sort;

public class Shell implements Sort {
    @Override
    public void sort(int[] a) {
        int N = a.length;
        int h = 1;
        while (h < N / 2) h = 2 * h;
        while (h >= 1) {
            for (int i = h; i < N; i++) {
                for (int j = i; j >= h; j -= h) {
                    if (a[j] < a[j - h]) {
                        int temp = a[j];
                        a[j] = a[j - h];
                        a[j - h] = temp;
                    }
                }
            }
            h = h / 2;
        }
    }
}
```

参考如上.我们先构造了一个尽可能大的数字,比如这里我们利用循环构造了一个数字2^n<a.length

比如length长度为20,那么h就是16,然后第一遍循环先看第16个数字跟第一个数字的大小,视情况交换,然后j=j-h...然后比较a[17]和a[1]......

第一遍结束后应该是个16-有序数组,然后让h/2,让这个数组变为8-有序,4-有序,2-有序,1-有序...

1-有序自然就是一个常规的有序列表了

还是很简单的...